1. Какие данные могут хранить коллекции?
Коллекции могут хранить любые ссылочные типы данных.
2. 2. Какова иерархия коллекций?
Iterable -> Collection -> List, Set, Queue ->
LinkedList, ArrayList
HashSet, LinkedHashSet, SortedSet -> TreeSet
ArrayDeque, LinkedList
Vector -> Stack
Есть еще интерфейс Map он не наследует Collection
HashMap, LinkedHashMap, HashTable, SortedMap -> TreeMap
3. Какие реализации SortedSet бывают и в чем их особенность?
Реализацией Sortedset является TreeSet. TreeSet добавляет элементы в коллекцию по возрастанию.
4. Какие структуры поддерживают произвольный доступ к элементам?
Структуры данных основанные на массивах обеспечивают произвольный доступ к данным.
Например, ArrayList и HashMap.
5. В чем отличия/сходства List и Set?
Интерфейсы List и Set предлагают идентичный контракт для реализующих их классов.
Набор методов этих интерфейсов во многом одинаков, однако реализация Set не предполагает хранения дубликатов
объектов внутри и обеспечивает хранение единственного null значения.
List может хранить любое количество одинаковых объектов и null.
6. Что разного/общего у классов ArrayList и LinkedList, когда лучше использовать ArrayList, а когда
LinkedList?
ArrayList и LinkedList имплементируют интерфейс List имеют одинаковый набор методов.
Внутри ArrayList для хранения объектов используется массив, обеспечивающий произвольный доступ по индексу(выполняется быстро).
LinkedList для хранения данных содержит внутри объект Ноды. Нода хранит ссылку на предыдущий и на следующий элемент в коллекции, а также индекс,
за счет этого появляется возможность доступа к данным по индексу(выполняется медленно,
так как необходимо последовательно двигаться от головы или хвоста коллекции к заданному индексу).
В настоящее время для всех операций лучше использовать ArrayList, так как современные процессоры обладают достаточно большим кэшем и размером регистров.
Раньше можно было использовать линкед лист, когда требовалась произвольная вставка в середину списка, для этого требовалось лишь изменить ссылки.
При Вставке в середину списка, с с реализацией ArrayList требовалось перемещать объекты внутри массива.
7. В каких случаях разумно использовать массив, а не ArrayList?
Когда есть константное количество элементов и не требуется добавлять новые элементы.
8. Какие существуют методы удаления элементов из ArrayList?
метод remove(), removeAll(); В метод remove нужно передать либо индекс элемента, либо сам объект, который нужно удалить.
В метод removeAll() необходжимо передать коллекцию элементов которые должны быть удалены.
9. Чем отличается ArrayList от Vector?
Vector потокобезопасен, работает медленнее, чем ArrayList.
10. Как преобразовать массив в ArrayList и наоборот? Какие есть способы и отличия
Можно проитерироваться по массиву добавляя элементы в ArrayList.
Можно использовать класс Collections и метод addAll(Сollection, T[]), при этом массив должен быть не из примитивов.
Можно использовать StreamAPI. Arrays.stream(T[]).collect(Collectors.toList());
11. Чем отличаются HashMap и TreeMap? Как они устроены и работают? Что со временем доступа
к объектам? Какие области применения?
HashMap или ассоциативный массив имеет внутри себя массив, внутри которого находятся связанные списки.
Попадание объекта в индекс массива (корзину) происходит пол hashCode.
Если hashCode у нескольких объектов совпадают, то в этом индексе создается свзяанный список.
В общем случае доступ к элементам обеспечивается за время O(1). Но если много коллизий, то за время O(n);
TreeMap построена на красно-черных деревьях. Доступ к элементам производится за время O(Log(n));
В красно-черных деревьях объекты хранятся следующим образом. Создается корень дерева, далее элементы добавляются следующим образом, если значение больше
то оно добавляется в правый дочерний узел, если меньше то в левый узел. За счет этого итерирование по дереву осуществялется за время Log(n);
Корень дерева всегда окрашивается в черный цвет.
У красного узла, оба дочерних узла долдны быть черными.
Листья дерева должны быть черного цвета.
Высота красно-черноого дерева называется черной высотой и считается по количеству черных узлов.
12. Почему Map не наследуется от Collection?
Потому что Map использует пары ключ значение и методы Collection не умеют с этой парой работать.
13. Что такое Map.entry?
Map.Entry это объект описывающий пару "Ключ" - "значение".
14. Что будет, если в Map положить два значения с одинаковым ключом?
Старое значение перезапишется.
Это поведение можно изменить используя метод computeIfAbsent();
15. Что такое хэш-коллизия и как с этим справиться?
Хэш-коллизия возникает при наличии одинаковых hashCode у добавляемых в map объектов.
Чтобы уменьшить количество хэш-коллизий нужно реализовать hashCode так, чтобы они редко повторялись.
При возникновении хэш-коллизии в корзине соаздается LinkedList;
16. Почему не стоит использовать byte[] в качестве ключа в HashMap?
Потому что hashCode массива не зависит от хранимых в нем элементов.
17. В каком случае может быть потерян элемент в HashMap?
Если в качестве ключа используется mutable объект и он изменился.
18. Что такое Hashtable, чем она отличается от HashMap? Какие альтернативы?
Методы хэш таблицы синхронизированы, она работает медленнее. Альтернатива HashMap.
19. Чем отличается IdentityHashMap?
В работе IdentityHashMap не используются equals и hashCode.
Объекты сравниваются на равенство ссылок.
20. Какие методы есть, чтобы отсортировать любую коллекцию? Как они работают?
Отсортировать коллецию можно с использованием статического метода класса Collections.sort().
Можно с использованием StreamAPI используя промежуточный метод sorted();
Есил классы реализуют интрефейс comparable, то такие методы отсортируют коллекцию в natural order.
Если интрефейс comparable не реаилзован, в эти методы вторым аргуметном можно передать компратор.
21. Как задается порядок следования объектов в коллекции?
Порядок можно задать естественнным порядком, либо используя Comparator.
22. В чем разница между интерфейсами Comparable и Comparator?
Comparable интрефейся имеющий метод comapreTo(T t), реализует логику сравнения для объектов этого класса.
Comparator можно сделать обобщенным для сравнения любых объектов. Нужно переопределить метод compare(T t1, T t2);
23. Что подразумевается под sorted и ordered в коллекциях?
Ordered означает, что элементы в коллекции упорядочены.
Sorted ощзначет что элементы отсортированы по какому либо правилу.
24. Дать определение понятию “итератор”.
Итератор это объект позволяющий проходить по всем элементам коллекции.
25. Какую функциональность представляет класс Collections?
Collections это утильный класс, позволяющий обрабатывать коллекции.
Например выоплнять сортировку коллекций, заполнять коллекции набором элементов и т.д.
26. Какие коллекции синхронизированы?
HashTable, Vector.
27. Как получить синхронизированную коллекцию из не синхронизированной?
Вызвать метод утильного класса Collections.synchronized...(Collection<> col);
Создать обертку над необходимой структурой данных
28. Как получить коллекцию только для чтения?
Вызвать метод утильного класса Collections.unmodifiable...(Collection<> col);
29. В чем разница между Iterator и Enumeration?
Оба интрфейса предназначены для итерирования по элементам коллекции.
Enumeration является устаревшим, его имплементируют Vector, Stack, Hashtable.
Он не позволяет изменять коллекцию во время обхода, может обходить коллекцию только в одном направлении.
30. В чем разница между Iterator и ListIterator?
ListIterator позволяет обходить коллекцию в двух направлениях и изменять элементы коллекции.
31. В чем разница между fail-safe и fail-fast свойствами?
Fail-fast это свойство Iterator выбрасывать ConcurrentModificationException при одновременном доступе к коллекции двух итераторов
при имзении количества элементов коллекции.
Fail-safe Iterator никода не выбросит исключение ConcurrentModificationException, так как создает копию коллекции и обходит ее.
Такой итератор не может менять элементы коллекции.
32. Что делать, чтобы не возникло исключение ConcurrentModificationException?
Использовать итератор для обхода коллекции и удалять элеенты используя метод iterator.remove();
33. Что такое стек и очередь? Какие бывают очереди?
Это логические структуры данных, являющихся абстракциями над очередью и стопкой.
Подчиняются правилам FIFO и FILO.
34. Какие коллекции удобно использовать с enum? Как их создавать и при каких условиях?
Существуют специальные коллекции EnumSet и EnumMap.
EnumSet эффективно хранит элменты и проверяет наличие элементов в Set.
EnumMap в качестве ключей использует Enum.
35. Каковы лучшие практики в рамках Коллекций?
Использовать подходящие для задач коллекции
Использовать параметризированные коллекции.
Избегать старых коллекций
Задавать начальную емкость коллекции (ожидаемый размер).
ИСпользовать интрефейсы коллекций вместо их реализаци.





